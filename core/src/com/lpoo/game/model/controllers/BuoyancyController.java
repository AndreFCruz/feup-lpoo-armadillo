/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2014 Leakedbits
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

package com.lpoo.game.model.controllers;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.physics.box2d.Body;
import com.badlogic.gdx.physics.box2d.Fixture;
import com.badlogic.gdx.physics.box2d.PolygonShape;
import com.badlogic.gdx.physics.box2d.World;
import com.lpoo.game.model.utils.PolygonIntersector;
import com.lpoo.game.model.utils.PolygonProperties;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * Class responsible for handling the buoyancy of fluids.
 */
public class BuoyancyController {

    /**
     * Boolean if set fluid is fixed. If not, fluid is not fixed.
     */
    private boolean isFluidFixed = true;
    /**
     * Fluid's dragging constant.
     */
    private float fluidDrag = 0.25f;
    /**
     * Fluid's lifting constant
     */
    private float fluidLift = 0.25f;
    /**
     * Fluid's liner dragging constant
     */
    private float linearDrag = 0.1f;
    /**
     * Fluid's maximum dragging constant
     */
    private float maxFluidDrag = 2000;
    /**
     * Fluid's maximum lifting constant
     */
    private float maxFluidLift = 500;
    /**
     * Fluid's initial fixture.
     */
    private Fixture fluidSensor;
    /**
     * List containing the fluid associated vertices.
     */
    private List<Vector2> fluidVertices;
    /**
     * Set containing the fixtures that will be generated and associated to the fluid.
     */
    private Set<Fixture> fixtures;
    /**
     * The world the buoyancy controller will be used in.
     */
    private World world;

    /**
     * Buoyancy Controller's constructor, from a the fluid's fixture and fluid's world.
     *
     * @param world       The world the buoyancy controller will be used in.
     * @param fluidSensor The fluid's fixture.
     */
    public BuoyancyController(World world, Fixture fluidSensor) {
        this.world = world;
        this.fluidSensor = fluidSensor;
        fluidVertices = getFixtureVertices(fluidSensor);

        fixtures = new HashSet<>();
    }

    /**
     * Function called in the game loop, responsible for updating the fluid.
     */
    public void step() {
        for (Fixture fixture : fixtures) {
            if (fixture.getBody().isAwake()) {

				/* Create clipPolygon */
                List<Vector2> clipPolygon = getFixtureVertices(fixture);

				/* Create subjectPolygon */
                List<Vector2> subjectPolygon;
                if (isFluidFixed) {
                    subjectPolygon = fluidVertices;
                } else
                    subjectPolygon = getFixtureVertices(fluidSensor);

				/* Get intersection polygon */
                List<Vector2> clippedPolygon = PolygonIntersector.clipPolygons(
                        subjectPolygon, clipPolygon);

                if (!clippedPolygon.isEmpty()) {
                    applyForces(fixture, clippedPolygon.toArray(new Vector2[0]));
                }
            }
        }
    }

    /**
     * Applies the forces generated by the fluid into the given fixture.
     *
     * @param fixture        Fixture to be handled.
     * @param clippedPolygon Vertices representing the clipped polygon.
     */
    private void applyForces(Fixture fixture, Vector2[] clippedPolygon) {
        PolygonProperties polygonProperties = PolygonIntersector
                .computePolygonProperties(clippedPolygon);

		/* Get fixtures bodies */
        Body fixtureBody = fixture.getBody();
        Body fluidBody = fluidSensor.getBody();

		/* Get fluid density */
        float density = fluidSensor.getDensity();

		/* Apply buoyancy force */
        float displacedMass = fluidSensor.getDensity()
                * polygonProperties.getArea();
        Vector2 gravity = world.getGravity();
        Vector2 buoyancyForce = new Vector2(-gravity.x * displacedMass,
                -gravity.y * displacedMass);
        fixtureBody.applyForce(buoyancyForce, polygonProperties.getCentroid(),
                true);

		/* Linear drag force */
        if (linearDrag != 0) {
            fixtureBody.applyForce(gravity.rotate90(1).nor().scl(linearDrag),
                    polygonProperties.getCentroid(), true);
        }

		/* Apply drag and lift forces */
        int polygonVertices = clippedPolygon.length;
        for (int i = 0; i < polygonVertices; i++) {

			/* Apply drag force */

			/* End points and mid point of the edge */
            Vector2 firstPoint = clippedPolygon[i];
            Vector2 secondPoint = clippedPolygon[(i + 1) % polygonVertices];
            Vector2 midPoint = firstPoint.cpy().add(secondPoint).scl(0.5f);

			/*
             * Find relative velocity between the object and the fluid at edge
			 * mid point.
			 */
            Vector2 velocityDirection = new Vector2(fixtureBody
                    .getLinearVelocityFromWorldPoint(midPoint)
                    .sub(fluidBody.getLinearVelocityFromWorldPoint(midPoint)));
            float velocity = velocityDirection.len();
            velocityDirection.nor();

            Vector2 edge = secondPoint.cpy().sub(firstPoint);
            float edgeLength = edge.len();
            edge.nor();

            Vector2 normal = new Vector2(edge.y, -edge.x);
            float dragDot = normal.dot(velocityDirection);

            if (dragDot >= 0) {

				/*
                 * Normal don't point backwards. This is a leading edge. Store
				 * the result of multiply edgeLength, density and velocity
				 * squared
				 */
                float tempProduct = edgeLength * density * velocity * velocity;

                float drag = dragDot * fluidDrag * tempProduct;
                drag = Math.min(drag, maxFluidDrag);
                Vector2 dragForce = velocityDirection.cpy().scl(-drag);
                fixtureBody.applyForce(dragForce, midPoint, true);

				/* Apply lift force */
                float liftDot = edge.dot(velocityDirection);
                float lift = dragDot * liftDot * fluidLift * tempProduct;
                lift = Math.min(lift, maxFluidLift);
                Vector2 liftDirection = new Vector2(-velocityDirection.y,
                        velocityDirection.x);
                Vector2 liftForce = liftDirection.scl(lift);
                fixtureBody.applyForce(liftForce, midPoint, true);
            }
        }
    }

    /**
     * Adds a given fixture to the Fixtures container.
     *
     * @param fixture The fixture to be added.
     */
    public void addBody(Fixture fixture) {
        try {
            PolygonShape polygon = (PolygonShape) fixture.getShape();
            if (polygon.getVertexCount() > 2) {
                fixtures.add(fixture);
            }
        } catch (ClassCastException e) {
            Gdx.app.debug("BuoyancyController", "Fixture shape is not an instance of PolygonShape.");
        }
    }

    /**
     * Removes the given fixture from the Fixtures container.
     *
     * @param fixture Fixture to be removed.
     */
    public void removeBody(Fixture fixture) {
        fixtures.remove(fixture);
    }

    /**
     * Getter for the Vertices of a given Fixture.
     *
     * @param fixture Fixture to be handled.
     * @return List containing the Fixture's vertices.
     */
    private List<Vector2> getFixtureVertices(Fixture fixture) {
        PolygonShape polygon = (PolygonShape) fixture.getShape();
        int verticesCount = polygon.getVertexCount();

        List<Vector2> vertices = new ArrayList<>(verticesCount);
        for (int i = 0; i < verticesCount; i++) {
            Vector2 vertex = new Vector2();
            polygon.getVertex(i, vertex);
            vertices.add(new Vector2(fixture.getBody().getWorldPoint(vertex)));
        }

        return vertices;
    }
}